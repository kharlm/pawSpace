{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport invariant from \"../utils/invariant\";\nimport getScreenForRouteName from \"./getScreenForRouteName\";\nimport createConfigGetter from \"./createConfigGetter\";\nimport NavigationActions from \"../NavigationActions\";\nimport StackActions from \"./StackActions\";\nimport validateRouteConfigMap from \"./validateRouteConfigMap\";\nimport { createPathParser } from \"./pathUtils\";\n\nvar defaultActionCreators = function defaultActionCreators() {\n  return {};\n};\n\nfunction childrenUpdateWithoutSwitchingIndex(actionType) {\n  return [NavigationActions.SET_PARAMS, StackActions.COMPLETE_TRANSITION].includes(actionType);\n}\n\nexport default (function (routeConfigs) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validateRouteConfigMap(routeConfigs);\n  var order = config.order || Object.keys(routeConfigs);\n  var getCustomActionCreators = config.getCustomActionCreators || defaultActionCreators;\n  var initialRouteParams = config.initialRouteParams;\n  var initialRouteName = config.initialRouteName || order[0];\n  var backBehavior = config.backBehavior || 'none';\n  var resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;\n  var initialRouteIndex = order.indexOf(initialRouteName);\n\n  if (initialRouteIndex === -1) {\n    throw new Error(\"Invalid initialRouteName '\" + initialRouteName + \"'.\" + (\"Should be one of \" + order.map(function (n) {\n      return \"\\\"\" + n + \"\\\"\";\n    }).join(', ')));\n  }\n\n  var childRouters = {};\n  order.forEach(function (routeName) {\n    childRouters[routeName] = null;\n    var screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    var routeConfig = routeConfigs[routeName];\n\n    if (routeConfig && routeConfig.params) {\n      return _objectSpread({}, routeConfig.params, params);\n    } else {\n      return params;\n    }\n  }\n\n  var _createPathParser = createPathParser(childRouters, routeConfigs, config),\n      getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,\n      _getActionForPathAndParams = _createPathParser.getActionForPathAndParams;\n\n  function resetChildRoute(routeName) {\n    var initialParams = routeName === initialRouteName ? initialRouteParams : undefined;\n    var params = getParamsForRoute(routeName, initialParams);\n    var childRouter = childRouters[routeName];\n\n    if (childRouter) {\n      var childAction = NavigationActions.init();\n      return _objectSpread({}, childRouter.getStateForAction(childAction), {\n        key: routeName,\n        routeName: routeName,\n        params: params\n      });\n    }\n\n    return {\n      key: routeName,\n      routeName: routeName,\n      params: params\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(nextState) {\n      if (backBehavior !== 'history') {\n        return nextState;\n      }\n\n      var nextRouteKeyHistory = prevState.routeKeyHistory;\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = _toConsumableArray(prevState.routeKeyHistory);\n        var keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(function (k) {\n          return k !== keyToAdd;\n        });\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = _toConsumableArray(prevState.routeKeyHistory);\n        nextRouteKeyHistory.pop();\n      }\n\n      return _objectSpread({}, nextState, {\n        routeKeyHistory: nextRouteKeyHistory\n      });\n    }\n\n    var nextState = possibleNextState;\n\n    if (prevState && prevState.index !== possibleNextState.index && resetOnBlur) {\n      var prevRouteName = prevState.routes[prevState.index].routeName;\n\n      var nextRoutes = _toConsumableArray(possibleNextState.routes);\n\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = _objectSpread({}, possibleNextState, {\n        routes: nextRoutes\n      });\n    }\n\n    return updateNextStateHistory(nextState);\n  }\n\n  function getInitialState() {\n    var routes = order.map(resetChildRoute);\n    var initialState = {\n      routes: routes,\n      index: initialRouteIndex,\n      isTransitioning: false\n    };\n\n    if (backBehavior === 'history') {\n      var initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n\n    return initialState;\n  }\n\n  return {\n    childRouters: childRouters,\n    getActionCreators: function getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n    getStateForAction: function getStateForAction(action, inputState) {\n      var prevState = inputState ? _objectSpread({}, inputState) : inputState;\n      var state = inputState || getInitialState();\n      var activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        var params = action.params;\n\n        if (params) {\n          state.routes = state.routes.map(function (route) {\n            return _objectSpread({}, route, {\n              params: _objectSpread({}, route.params, params, route.routeName === initialRouteName ? initialRouteParams : null)\n            });\n          });\n        }\n      }\n\n      var activeChildLastState = state.routes[state.index];\n      var activeChildRouter = childRouters[order[state.index]];\n\n      if (activeChildRouter) {\n        var activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);\n\n        if (!activeChildState && inputState) {\n          return null;\n        }\n\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          var _routes = _toConsumableArray(state.routes);\n\n          _routes[state.index] = activeChildState;\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            routes: _routes\n          }));\n        }\n      }\n\n      var isBackEligible = action.key == null || action.key === activeChildLastState.key;\n\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        } else if (isBackEligible && backBehavior === 'history' && state.routeKeyHistory.length > 1) {\n            var routeKey = state.routeKeyHistory[state.routeKeyHistory.length - 2];\n            activeChildIndex = order.indexOf(routeKey);\n          } else {\n            return state;\n          }\n      }\n\n      var didNavigate = false;\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find(function (childId, i) {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (didNavigate) {\n          var childState = state.routes[activeChildIndex];\n          var childRouter = childRouters[action.routeName];\n          var newChildState = childState;\n\n          if (action.action && childRouter) {\n            var childStateUpdate = childRouter.getStateForAction(action.action, childState);\n\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = _objectSpread({}, newChildState, {\n              params: _objectSpread({}, newChildState.params || {}, action.params)\n            });\n          }\n\n          if (newChildState !== childState) {\n            var _routes2 = _toConsumableArray(state.routes);\n\n            _routes2[activeChildIndex] = newChildState;\n\n            var nextState = _objectSpread({}, state, {\n              routes: _routes2,\n              index: activeChildIndex\n            });\n\n            return getNextState(action, prevState, nextState);\n          } else if (newChildState === childState && state.index === activeChildIndex && prevState) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n\n        if (lastRoute) {\n          var _params = _objectSpread({}, lastRoute.params, action.params);\n\n          var _routes3 = _toConsumableArray(state.routes);\n\n          _routes3[state.routes.indexOf(lastRoute)] = _objectSpread({}, lastRoute, {\n            params: _params\n          });\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            routes: _routes3\n          }));\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          index: activeChildIndex\n        }));\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return _objectSpread({}, state);\n      }\n\n      var index = state.index;\n      var routes = state.routes;\n      order.find(function (childId, i) {\n        var childRouter = childRouters[childId];\n\n        if (i === index) {\n          return false;\n        }\n\n        var childState = routes[i];\n\n        if (childRouter) {\n          childState = childRouter.getStateForAction(action, childState);\n        }\n\n        if (!childState) {\n          index = i;\n          return true;\n        }\n\n        if (childState !== routes[i]) {\n          routes = _toConsumableArray(routes);\n          routes[i] = childState;\n          index = i;\n          return true;\n        }\n\n        return false;\n      });\n\n      if (childrenUpdateWithoutSwitchingIndex(action.type)) {\n        index = state.index;\n      }\n\n      if (index !== state.index || routes !== state.routes) {\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          index: index,\n          routes: routes\n        }));\n      }\n\n      return state;\n    },\n    getComponentForState: function getComponentForState(state) {\n      var routeName = state.routes[state.index].routeName;\n      invariant(routeName, \"There is no route defined for index \" + state.index + \". Check that\\n        that you passed in a navigation state with a valid tab/screen index.\");\n      var childRouter = childRouters[routeName];\n\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(path, params) {\n      return _getActionForPathAndParams(path, params);\n    },\n    getScreenOptions: createConfigGetter(routeConfigs, config.defaultNavigationOptions)\n  };\n});","map":{"version":3,"sources":["../../src/routers/SwitchRouter.js"],"names":["defaultActionCreators","NavigationActions","StackActions","config","validateRouteConfigMap","order","Object","getCustomActionCreators","initialRouteParams","initialRouteName","backBehavior","resetOnBlur","initialRouteIndex","n","childRouters","routeName","screen","getScreenForRouteName","routeConfig","routeConfigs","getActionForPathAndParams","createPathParser","initialParams","params","getParamsForRoute","childRouter","childAction","key","nextRouteKeyHistory","prevState","action","keyToAdd","nextState","k","routeKeyHistory","possibleNextState","prevRouteName","nextRoutes","resetChildRoute","routes","updateNextStateHistory","initialState","index","isTransitioning","initialKey","getActionCreators","getStateForAction","inputState","state","getInitialState","activeChildIndex","route","activeChildLastState","activeChildRouter","activeChildState","getNextState","isBackEligible","Math","routeKey","didNavigate","childId","childState","newChildState","childStateUpdate","lastRoute","i","childrenUpdateWithoutSwitchingIndex","getComponentForState","invariant","getComponentForRouteName","getPathAndParamsForState","getPathAndParamsForRoute","getScreenOptions","createConfigGetter"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport NavigationActions from '../NavigationActions';\nimport StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = () => ({});\n\nfunction childrenUpdateWithoutSwitchingIndex(actionType) {\n  return [\n    NavigationActions.SET_PARAMS,\n    // Todo: make SwitchRouter not depend on StackActions..\n    StackActions.COMPLETE_TRANSITION,\n  ].includes(actionType);\n}\n\nexport default (routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n\n  const getCustomActionCreators =\n    config.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteParams = config.initialRouteParams;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur')\n    ? config.resetOnBlur\n    : true;\n\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}'.` +\n        `Should be one of ${order.map(n => `\"${n}\"`).join(', ')}`\n    );\n  }\n\n  const childRouters = {};\n  order.forEach(routeName => {\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...params };\n    } else {\n      return params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, config);\n\n  function resetChildRoute(routeName) {\n    let initialParams =\n      routeName === initialRouteName ? initialRouteParams : undefined;\n    // note(brentvatne): merging initialRouteParams *on top* of default params\n    // on the route seems incorrect but it's consistent with existing behavior\n    // in stackrouter\n    let params = getParamsForRoute(routeName, initialParams);\n    const childRouter = childRouters[routeName];\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return {\n        ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        params,\n      };\n    }\n    return {\n      key: routeName,\n      routeName,\n      params,\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(nextState) {\n      if (backBehavior !== 'history') {\n        return nextState;\n      }\n      let nextRouteKeyHistory = prevState.routeKeyHistory;\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = [...prevState.routeKeyHistory]; // copy\n        const keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(k => k !== keyToAdd); // dedup\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = [...prevState.routeKeyHistory]; // copy\n        nextRouteKeyHistory.pop();\n      }\n      return {\n        ...nextState,\n        routeKeyHistory: nextRouteKeyHistory,\n      };\n    }\n\n    let nextState = possibleNextState;\n    if (\n      prevState &&\n      prevState.index !== possibleNextState.index &&\n      resetOnBlur\n    ) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = {\n        ...possibleNextState,\n        routes: nextRoutes,\n      };\n    }\n    return updateNextStateHistory(nextState);\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    const initialState = {\n      routes,\n      index: initialRouteIndex,\n      isTransitioning: false,\n    };\n    if (backBehavior === 'history') {\n      const initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n    return initialState;\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState } : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map(route => ({\n            ...route,\n            params: {\n              ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName\n                ? initialRouteParams\n                : null),\n            },\n          }));\n        }\n      }\n\n      // Let the current child handle it\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(\n          action,\n          activeChildLastState\n        );\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n      const isBackEligible =\n        action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        }\n        // The history contains current route, so we can only go back\n        // if there is more than one item in the history\n        else if (\n          isBackEligible &&\n          backBehavior === 'history' &&\n          state.routeKeyHistory.length > 1\n        ) {\n          const routeKey =\n            state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        } else {\n          return state;\n        }\n      }\n\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState = childState;\n\n          if (action.action && childRouter) {\n            const childStateUpdate = childRouter.getStateForAction(\n              action.action,\n              childState\n            );\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = {\n              ...newChildState,\n              params: {\n                ...(newChildState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            const nextState = {\n              ...state,\n              routes,\n              index: activeChildIndex,\n            };\n            return getNextState(action, prevState, nextState);\n          } else if (\n            newChildState === childState &&\n            state.index === activeChildIndex &&\n            prevState\n          ) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, {\n          ...state,\n          index: activeChildIndex,\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state };\n      }\n\n      // Let other children handle it and switch to the first child that returns a new state\n      let index = state.index;\n      let routes = state.routes;\n      order.find((childId, i) => {\n        const childRouter = childRouters[childId];\n        if (i === index) {\n          return false;\n        }\n        let childState = routes[i];\n        if (childRouter) {\n          childState = childRouter.getStateForAction(action, childState);\n        }\n        if (!childState) {\n          index = i;\n          return true;\n        }\n        if (childState !== routes[i]) {\n          routes = [...routes];\n          routes[i] = childState;\n          index = i;\n          return true;\n        }\n        return false;\n      });\n\n      // Nested routers can be updated after switching children with actions such as SET_PARAMS\n      // and COMPLETE_TRANSITION.\n      // NOTE: This may be problematic with custom routers because we whitelist the actions\n      // that can be handled by child routers without automatically changing index.\n      if (childrenUpdateWithoutSwitchingIndex(action.type)) {\n        index = state.index;\n      }\n\n      if (index !== state.index || routes !== state.routes) {\n        return getNextState(action, prevState, {\n          ...state,\n          index,\n          routes,\n        });\n      }\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.defaultNavigationOptions\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}