{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nvar _jsxFileName = \"/Users/kharl/pawSpace/node_modules/react-navigation-stack/src/views/StackView/StackViewLayout.js\";\nimport React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport View from \"react-native-web/dist/exports/View\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport { SceneView, StackActions, NavigationActions, NavigationProvider } from '@react-navigation/core';\nimport { withOrientation } from '@react-navigation/native';\nimport { ScreenContainer } from 'react-native-screens';\nimport { PanGestureHandler, State } from 'react-native-gesture-handler';\nimport Card from \"./StackViewCard\";\nimport Header from \"../Header/Header\";\nimport TransitionConfigs from \"./StackViewTransitionConfigs\";\nimport HeaderStyleInterpolator from \"../Header/HeaderStyleInterpolator\";\nimport StackGestureContext from \"../../utils/StackGestureContext\";\nimport clamp from \"../../utils/clamp\";\nimport { supportsImprovedSpringAnimation } from \"../../utils/ReactNativeFeatures\";\nvar IPHONE_XS_HEIGHT = 812;\nvar IPHONE_XR_HEIGHT = 896;\n\nvar _Dimensions$get = Dimensions.get('window'),\n    WINDOW_WIDTH = _Dimensions$get.width,\n    WINDOW_HEIGHT = _Dimensions$get.height;\n\nvar IS_IPHONE_X = Platform.OS === 'ios' && !Platform.isPad && !Platform.isTVOS && (WINDOW_HEIGHT === IPHONE_XS_HEIGHT || WINDOW_WIDTH === IPHONE_XS_HEIGHT || WINDOW_HEIGHT === IPHONE_XR_HEIGHT || WINDOW_WIDTH === IPHONE_XR_HEIGHT);\nvar EaseInOut = Easing.inOut(Easing.ease);\nvar HEADER_LAYOUT_PRESET = ['center', 'left'];\nvar HEADER_TRANSITION_PRESET = ['fade-in-place', 'uikit'];\nvar HEADER_BACKGROUND_TRANSITION_PRESET = ['toggle', 'fade', 'translate'];\nvar ANIMATION_DURATION = 500;\nvar POSITION_THRESHOLD = 1 / 2;\nvar GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nvar GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\nvar USE_NATIVE_DRIVER = true;\n\nvar getDefaultHeaderHeight = function getDefaultHeaderHeight(isLandscape) {\n  if (Platform.OS === 'ios') {\n    if (isLandscape && !Platform.isPad) {\n      return 32;\n    } else if (IS_IPHONE_X) {\n      return 88;\n    } else {\n      return 64;\n    }\n  } else if (Platform.OS === 'android') {\n    return 56;\n  } else {\n    return 64;\n  }\n};\n\nvar StackViewLayout = function (_React$Component) {\n  _inherits(StackViewLayout, _React$Component);\n\n  function StackViewLayout(props) {\n    var _this;\n\n    _classCallCheck(this, StackViewLayout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(StackViewLayout).call(this, props));\n    _this._immediateIndex = null;\n\n    _this._onFloatingHeaderLayout = function (e) {\n      var height = e.nativeEvent.layout.height;\n\n      if (height !== _this.state.floatingHeaderHeight) {\n        _this.setState({\n          floatingHeaderHeight: height\n        });\n      }\n    };\n\n    _this._handlePanGestureStateChange = function (_ref) {\n      var nativeEvent = _ref.nativeEvent;\n\n      if (nativeEvent.oldState === State.ACTIVE) {\n        if (_this.positionSwitch.__getValue() === 1) {\n          return;\n        }\n\n        if (_this._isMotionVertical()) {\n          _this._handleReleaseVertical(nativeEvent);\n        } else {\n          _this._handleReleaseHorizontal(nativeEvent);\n        }\n      } else if (nativeEvent.state === State.ACTIVE) {\n        _this.props.onGestureBegin && _this.props.onGestureBegin();\n\n        _this.positionSwitch.setValue(0);\n      }\n    };\n\n    _this._renderCard = function (scene) {\n      var _this$props = _this.props,\n          transitionProps = _this$props.transitionProps,\n          shadowEnabled = _this$props.shadowEnabled,\n          cardOverlayEnabled = _this$props.cardOverlayEnabled,\n          transparentCard = _this$props.transparentCard,\n          cardStyle = _this$props.cardStyle;\n      var screenInterpolator = _this._transitionConfig.screenInterpolator;\n      var style = screenInterpolator && screenInterpolator(_objectSpread({}, transitionProps, {\n        shadowEnabled: shadowEnabled,\n        cardOverlayEnabled: cardOverlayEnabled,\n        position: _this.position,\n        scene: scene\n      }));\n      var options = scene.descriptor.options;\n      var hasHeader = options.header !== null;\n\n      var headerMode = _this._getHeaderMode();\n\n      var paddingTopStyle;\n\n      if (hasHeader && headerMode === 'float' && !options.headerTransparent) {\n        paddingTopStyle = {\n          paddingTop: _this.state.floatingHeaderHeight\n        };\n      }\n\n      return React.createElement(Card, _extends({}, transitionProps, {\n        key: \"card_\" + scene.key,\n        position: _this.position,\n        realPosition: transitionProps.position,\n        animatedStyle: style,\n        transparent: transparentCard,\n        style: [paddingTopStyle, cardStyle],\n        scene: scene,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 862\n        }\n      }), _this._renderInnerScene(scene));\n    };\n\n    _this.panGestureRef = React.createRef();\n    _this.gestureX = new Animated.Value(0);\n    _this.gestureY = new Animated.Value(0);\n    _this.positionSwitch = new Animated.Value(1);\n\n    if (Animated.subtract) {\n      _this.gestureSwitch = Animated.subtract(1, _this.positionSwitch);\n    } else {\n      _this.gestureSwitch = Animated.add(1, Animated.multiply(-1, _this.positionSwitch));\n    }\n\n    _this.gestureEvent = Animated.event([{\n      nativeEvent: {\n        translationX: _this.gestureX,\n        translationY: _this.gestureY\n      }\n    }], {\n      useNativeDriver: USE_NATIVE_DRIVER\n    });\n    _this.state = {\n      floatingHeaderHeight: getDefaultHeaderHeight(props.isLandscape)\n    };\n    return _this;\n  }\n\n  _createClass(StackViewLayout, [{\n    key: \"_renderHeader\",\n    value: function _renderHeader(scene, headerMode) {\n      var options = scene.descriptor.options;\n      var header = options.header;\n\n      if (__DEV__ && typeof header === 'string') {\n        throw new Error(\"Invalid header value: \\\"\" + header + \"\\\". The header option must be a valid React component or null, not a string.\");\n      }\n\n      if (header === null && headerMode === 'screen') {\n        return null;\n      }\n\n      if (React.isValidElement(header)) {\n        return header;\n      }\n\n      var renderHeader = header || function (props) {\n        return React.createElement(Header, _extends({}, props, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 156\n          }\n        }));\n      };\n\n      var _this$_transitionConf = this._transitionConfig,\n          headerLeftInterpolator = _this$_transitionConf.headerLeftInterpolator,\n          headerTitleInterpolator = _this$_transitionConf.headerTitleInterpolator,\n          headerRightInterpolator = _this$_transitionConf.headerRightInterpolator,\n          headerBackgroundInterpolator = _this$_transitionConf.headerBackgroundInterpolator;\n\n      var backgroundTransitionPresetInterpolator = this._getHeaderBackgroundTransitionPreset();\n\n      if (backgroundTransitionPresetInterpolator) {\n        headerBackgroundInterpolator = backgroundTransitionPresetInterpolator;\n      }\n\n      var _this$props2 = this.props,\n          transitionProps = _this$props2.transitionProps,\n          passProps = _objectWithoutProperties(_this$props2, [\"transitionProps\"]);\n\n      return React.createElement(NavigationProvider, {\n        value: scene.descriptor.navigation,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 173\n        }\n      }, renderHeader(_objectSpread({}, passProps, transitionProps, {\n        position: this.position,\n        scene: scene,\n        mode: headerMode,\n        transitionPreset: this._getHeaderTransitionPreset(),\n        layoutPreset: this._getHeaderLayoutPreset(),\n        backTitleVisible: this._getHeaderBackTitleVisible(),\n        leftInterpolator: headerLeftInterpolator,\n        titleInterpolator: headerTitleInterpolator,\n        rightInterpolator: headerRightInterpolator,\n        backgroundInterpolator: headerBackgroundInterpolator\n      })));\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset(resetToIndex, duration) {\n      if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n        Animated.spring(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          stiffness: 6000,\n          damping: 100,\n          mass: 3,\n          overshootClamping: true,\n          restDisplacementThreshold: 0.01,\n          restSpeedThreshold: 0.01,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start();\n      } else {\n        Animated.timing(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start();\n      }\n    }\n  }, {\n    key: \"_goBack\",\n    value: function _goBack(backFromIndex, duration) {\n      var _this2 = this;\n\n      var _this$props$transitio = this.props.transitionProps,\n          navigation = _this$props$transitio.navigation,\n          position = _this$props$transitio.position,\n          scenes = _this$props$transitio.scenes;\n      var toValue = Math.max(backFromIndex - 1, 0);\n      this._immediateIndex = toValue;\n\n      var onCompleteAnimation = function onCompleteAnimation() {\n        _this2._immediateIndex = null;\n        var backFromScene = scenes.find(function (s) {\n          return s.index === toValue + 1;\n        });\n\n        if (backFromScene) {\n          navigation.dispatch(NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true\n          }));\n          navigation.dispatch(StackActions.completeTransition());\n        }\n      };\n\n      if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n        Animated.spring(position, {\n          toValue: toValue,\n          stiffness: 7000,\n          damping: 300,\n          mass: 3,\n          overshootClamping: true,\n          restDisplacementThreshold: 0.01,\n          restSpeedThreshold: 0.01,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start(onCompleteAnimation);\n      } else {\n        Animated.timing(position, {\n          toValue: toValue,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start(onCompleteAnimation);\n      }\n    }\n  }, {\n    key: \"_prepareAnimated\",\n    value: function _prepareAnimated() {\n      if (this.props === this._prevProps) {\n        return;\n      }\n\n      this._prevProps = this.props;\n\n      this._prepareGesture();\n\n      this._preparePosition();\n\n      this._prepareTransitionConfig();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this._prepareAnimated();\n\n      var transitionProps = this.props.transitionProps;\n      var index = transitionProps.navigation.state.index,\n          scenes = transitionProps.scenes;\n\n      var headerMode = this._getHeaderMode();\n\n      var floatingHeader = null;\n\n      if (headerMode === 'float') {\n        var scene = transitionProps.scene;\n        floatingHeader = React.createElement(View, {\n          style: styles.floatingHeader,\n          pointerEvents: \"box-none\",\n          onLayout: this._onFloatingHeaderLayout,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 291\n          }\n        }, this._renderHeader(scene, headerMode));\n      }\n\n      return React.createElement(PanGestureHandler, _extends({}, this._gestureActivationCriteria(), {\n        ref: this.panGestureRef,\n        onGestureEvent: this.gestureEvent,\n        onHandlerStateChange: this._handlePanGestureStateChange,\n        enabled: index > 0 && this._isGestureEnabled(),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 302\n        }\n      }), React.createElement(Animated.View, {\n        style: [styles.container, this._transitionConfig.containerStyle],\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 309\n        }\n      }, React.createElement(StackGestureContext.Provider, {\n        value: this.panGestureRef,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 312\n        }\n      }, React.createElement(ScreenContainer, {\n        style: styles.scenes,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 313\n        }\n      }, scenes.map(this._renderCard)), floatingHeader)));\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var prevState = prevProps.transitionProps.navigation.state;\n      var state = this.props.transitionProps.navigation.state;\n\n      if (prevState.index !== state.index) {\n        this._maybeCancelGesture();\n      }\n    }\n  }, {\n    key: \"_getGestureResponseDistance\",\n    value: function _getGestureResponseDistance() {\n      var scene = this.props.transitionProps.scene;\n      var options = scene.descriptor.options;\n      var _options$gestureRespo = options.gestureResponseDistance,\n          userGestureResponseDistance = _options$gestureRespo === void 0 ? {} : _options$gestureRespo;\n      return this._isModal() ? userGestureResponseDistance.vertical || GESTURE_RESPONSE_DISTANCE_VERTICAL : userGestureResponseDistance.horizontal || GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n    }\n  }, {\n    key: \"_gestureActivationCriteria\",\n    value: function _gestureActivationCriteria() {\n      var layout = this.props.transitionProps.layout;\n\n      var gestureResponseDistance = this._getGestureResponseDistance();\n\n      var isMotionInverted = this._isMotionInverted();\n\n      if (this._isMotionVertical()) {\n        var height = layout.height.__getValue();\n\n        return {\n          maxDeltaX: 15,\n          minOffsetY: isMotionInverted ? -5 : 5,\n          hitSlop: isMotionInverted ? {\n            top: -height + gestureResponseDistance\n          } : {\n            bottom: -height + gestureResponseDistance\n          }\n        };\n      } else {\n        var width = layout.width.__getValue();\n\n        var hitSlop = -width + gestureResponseDistance;\n        return {\n          minOffsetX: isMotionInverted ? -5 : 5,\n          maxDeltaY: 20,\n          hitSlop: isMotionInverted ? {\n            left: hitSlop\n          } : {\n            right: hitSlop\n          }\n        };\n      }\n    }\n  }, {\n    key: \"_isGestureEnabled\",\n    value: function _isGestureEnabled() {\n      var gesturesEnabled = this.props.transitionProps.scene.descriptor.options.gesturesEnabled;\n      return typeof gesturesEnabled === 'boolean' ? gesturesEnabled : Platform.OS === 'ios';\n    }\n  }, {\n    key: \"_isMotionVertical\",\n    value: function _isMotionVertical() {\n      return this._isModal();\n    }\n  }, {\n    key: \"_isModal\",\n    value: function _isModal() {\n      return this.props.mode === 'modal';\n    }\n  }, {\n    key: \"_isMotionInverted\",\n    value: function _isMotionInverted() {\n      var scene = this.props.transitionProps.scene;\n      var options = scene.descriptor.options;\n      var gestureDirection = options.gestureDirection;\n\n      if (this._isModal()) {\n        return gestureDirection === 'inverted';\n      } else {\n        return typeof gestureDirection === 'string' ? gestureDirection === 'inverted' : I18nManager.isRTL;\n      }\n    }\n  }, {\n    key: \"_computeHorizontalGestureValue\",\n    value: function _computeHorizontalGestureValue(_ref2) {\n      var translationX = _ref2.translationX;\n      var _this$props$transitio2 = this.props.transitionProps,\n          navigation = _this$props$transitio2.navigation,\n          layout = _this$props$transitio2.layout;\n      var index = navigation.state.index;\n\n      var distance = layout.width.__getValue();\n\n      var x = this._isMotionInverted() ? -1 * translationX : translationX;\n      var value = index - x / distance;\n      return clamp(index - 1, value, index);\n    }\n  }, {\n    key: \"_computeVerticalGestureValue\",\n    value: function _computeVerticalGestureValue(_ref3) {\n      var translationY = _ref3.translationY;\n      var _this$props$transitio3 = this.props.transitionProps,\n          navigation = _this$props$transitio3.navigation,\n          layout = _this$props$transitio3.layout;\n      var index = navigation.state.index;\n\n      var distance = layout.height.__getValue();\n\n      var y = this._isMotionInverted() ? -1 * translationY : translationY;\n      var value = index - y / distance;\n      return clamp(index - 1, value, index);\n    }\n  }, {\n    key: \"_maybeCancelGesture\",\n    value: function _maybeCancelGesture() {\n      this.positionSwitch.setValue(1);\n    }\n  }, {\n    key: \"_prepareGesture\",\n    value: function _prepareGesture() {\n      if (!this._isGestureEnabled()) {\n        if (this.positionSwitch.__getValue() !== 1) {\n          this.positionSwitch.setValue(1);\n        }\n\n        this.gesturePosition = undefined;\n        return;\n      }\n\n      if (this.props.transitionProps.layout.width.__getValue() === 0 || this.props.transitionProps.layout.height.__getValue() === 0) {\n        return;\n      }\n\n      if (this._isMotionVertical()) {\n        this._prepareGestureVertical();\n      } else {\n        this._prepareGestureHorizontal();\n      }\n    }\n  }, {\n    key: \"_prepareGestureHorizontal\",\n    value: function _prepareGestureHorizontal() {\n      var index = this.props.transitionProps.navigation.state.index;\n\n      if (this._isMotionInverted()) {\n        this.gesturePosition = Animated.add(index, Animated.divide(this.gestureX, this.props.transitionProps.layout.width)).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      } else {\n        this.gesturePosition = Animated.add(index, Animated.multiply(-1, Animated.divide(this.gestureX, this.props.transitionProps.layout.width))).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      }\n    }\n  }, {\n    key: \"_prepareGestureVertical\",\n    value: function _prepareGestureVertical() {\n      var index = this.props.transitionProps.navigation.state.index;\n\n      if (this._isMotionInverted()) {\n        this.gesturePosition = Animated.add(index, Animated.divide(this.gestureY, this.props.transitionProps.layout.height)).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      } else {\n        this.gesturePosition = Animated.add(index, Animated.multiply(-1, Animated.divide(this.gestureY, this.props.transitionProps.layout.height))).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      }\n    }\n  }, {\n    key: \"_handleReleaseHorizontal\",\n    value: function _handleReleaseHorizontal(nativeEvent) {\n      var _this$props$transitio4 = this.props.transitionProps,\n          navigation = _this$props$transitio4.navigation,\n          position = _this$props$transitio4.position,\n          layout = _this$props$transitio4.layout;\n      var index = navigation.state.index;\n      var immediateIndex = this._immediateIndex == null ? index : this._immediateIndex;\n\n      var distance = layout.width.__getValue();\n\n      var movementDirection = this._isMotionInverted() ? -1 : 1;\n      var movedDistance = movementDirection * nativeEvent.translationX;\n      var gestureVelocity = movementDirection * nativeEvent.velocityX;\n      var defaultVelocity = distance / ANIMATION_DURATION;\n      var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n      var resetDuration = this._isMotionInverted() ? (distance - movedDistance) / velocity : movedDistance / velocity;\n      var goBackDuration = this._isMotionInverted() ? movedDistance / velocity : (distance - movedDistance) / velocity;\n\n      var value = this._computeHorizontalGestureValue(nativeEvent);\n\n      position.setValue(value);\n      this.positionSwitch.setValue(1);\n\n      if (gestureVelocity < -50) {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n\n        this._reset(immediateIndex, resetDuration);\n\n        return;\n      }\n\n      if (gestureVelocity > 50) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n\n        this._goBack(immediateIndex, goBackDuration);\n\n        return;\n      }\n\n      if (value <= index - POSITION_THRESHOLD) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n\n        this._goBack(immediateIndex, goBackDuration);\n      } else {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n\n        this._reset(immediateIndex, resetDuration);\n      }\n    }\n  }, {\n    key: \"_handleReleaseVertical\",\n    value: function _handleReleaseVertical(nativeEvent) {\n      var _this$props$transitio5 = this.props.transitionProps,\n          navigation = _this$props$transitio5.navigation,\n          position = _this$props$transitio5.position,\n          layout = _this$props$transitio5.layout;\n      var index = navigation.state.index;\n      var immediateIndex = this._immediateIndex == null ? index : this._immediateIndex;\n\n      var distance = layout.height.__getValue();\n\n      var isMotionInverted = this._isMotionInverted();\n\n      var movementDirection = isMotionInverted ? -1 : 1;\n      var movedDistance = movementDirection * nativeEvent.translationY;\n      var gestureVelocity = movementDirection * nativeEvent.velocityY;\n      var defaultVelocity = distance / ANIMATION_DURATION;\n      var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n      var resetDuration = isMotionInverted ? (distance - movedDistance) / velocity : movedDistance / velocity;\n      var goBackDuration = isMotionInverted ? movedDistance / velocity : (distance - movedDistance) / velocity;\n\n      var value = this._computeVerticalGestureValue(nativeEvent);\n\n      position.setValue(value);\n      this.positionSwitch.setValue(1);\n\n      if (gestureVelocity < -50) {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n\n        this._reset(immediateIndex, resetDuration);\n\n        return;\n      }\n\n      if (gestureVelocity > 50) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n\n        this._goBack(immediateIndex, goBackDuration);\n\n        return;\n      }\n\n      if (value <= index - POSITION_THRESHOLD) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n\n        this._goBack(immediateIndex, goBackDuration);\n      } else {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n\n        this._reset(immediateIndex, resetDuration);\n      }\n    }\n  }, {\n    key: \"_getHeaderMode\",\n    value: function _getHeaderMode() {\n      if (this.props.headerMode) {\n        return this.props.headerMode;\n      }\n\n      if (Platform.OS !== 'ios' || this.props.mode === 'modal') {\n        return 'screen';\n      }\n\n      return 'float';\n    }\n  }, {\n    key: \"_getHeaderBackgroundTransitionPreset\",\n    value: function _getHeaderBackgroundTransitionPreset() {\n      var headerBackgroundTransitionPreset = this.props.headerBackgroundTransitionPreset;\n\n      if (headerBackgroundTransitionPreset) {\n        if (HEADER_BACKGROUND_TRANSITION_PRESET.includes(headerBackgroundTransitionPreset)) {\n          if (headerBackgroundTransitionPreset === 'fade') {\n            return HeaderStyleInterpolator.forBackgroundWithFade;\n          } else if (headerBackgroundTransitionPreset === 'translate') {\n            return HeaderStyleInterpolator.forBackgroundWithTranslation;\n          } else if (headerBackgroundTransitionPreset === 'toggle') {\n            return HeaderStyleInterpolator.forBackgroundWithInactiveHidden;\n          }\n        } else if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerBackgroundTransitionPreset - expected one of \" + HEADER_BACKGROUND_TRANSITION_PRESET.join(', ') + \" but received \" + JSON.stringify(headerBackgroundTransitionPreset));\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_getHeaderLayoutPreset\",\n    value: function _getHeaderLayoutPreset() {\n      var headerLayoutPreset = this.props.headerLayoutPreset;\n\n      if (headerLayoutPreset) {\n        if (__DEV__) {\n          if (this._getHeaderTransitionPreset() === 'uikit' && headerLayoutPreset === 'left' && Platform.OS === 'ios') {\n            console.warn(\"headerTransitionPreset with the value 'uikit' is incompatible with headerLayoutPreset 'left'\");\n          }\n        }\n\n        if (HEADER_LAYOUT_PRESET.includes(headerLayoutPreset)) {\n          return headerLayoutPreset;\n        }\n\n        if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerLayoutPreset - expected one of \" + HEADER_LAYOUT_PRESET.join(', ') + \" but received \" + JSON.stringify(headerLayoutPreset));\n        }\n      }\n\n      if (Platform.OS !== 'ios') {\n        return 'left';\n      } else {\n        return 'center';\n      }\n    }\n  }, {\n    key: \"_getHeaderTransitionPreset\",\n    value: function _getHeaderTransitionPreset() {\n      if (Platform.OS !== 'ios' || this._getHeaderMode() === 'screen') {\n        return 'fade-in-place';\n      }\n\n      var headerTransitionPreset = this.props.headerTransitionPreset;\n\n      if (headerTransitionPreset) {\n        if (HEADER_TRANSITION_PRESET.includes(headerTransitionPreset)) {\n          return headerTransitionPreset;\n        }\n\n        if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerTransitionPreset - expected one of \" + HEADER_TRANSITION_PRESET.join(', ') + \" but received \" + JSON.stringify(headerTransitionPreset));\n        }\n      }\n\n      return 'fade-in-place';\n    }\n  }, {\n    key: \"_getHeaderBackTitleVisible\",\n    value: function _getHeaderBackTitleVisible() {\n      var headerBackTitleVisible = this.props.headerBackTitleVisible;\n\n      var layoutPreset = this._getHeaderLayoutPreset();\n\n      var enabledByDefault = !(layoutPreset === 'left' || Platform.OS !== 'ios');\n      return typeof headerBackTitleVisible === 'boolean' ? headerBackTitleVisible : enabledByDefault;\n    }\n  }, {\n    key: \"_renderInnerScene\",\n    value: function _renderInnerScene(scene) {\n      var _scene$descriptor = scene.descriptor,\n          navigation = _scene$descriptor.navigation,\n          getComponent = _scene$descriptor.getComponent;\n      var SceneComponent = getComponent();\n      var screenProps = this.props.screenProps;\n\n      var headerMode = this._getHeaderMode();\n\n      if (headerMode === 'screen') {\n        return React.createElement(View, {\n          style: styles.container,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 784\n          }\n        }, React.createElement(View, {\n          style: styles.scenes,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 785\n          }\n        }, React.createElement(SceneView, {\n          screenProps: screenProps,\n          navigation: navigation,\n          component: SceneComponent,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 786\n          }\n        })), this._renderHeader(scene, headerMode));\n      }\n\n      return React.createElement(SceneView, {\n        screenProps: screenProps,\n        navigation: navigation,\n        component: SceneComponent,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 797\n        }\n      });\n    }\n  }, {\n    key: \"_prepareTransitionConfig\",\n    value: function _prepareTransitionConfig() {\n      this._transitionConfig = TransitionConfigs.getTransitionConfig(this.props.transitionConfig, _objectSpread({}, this.props.transitionProps, {\n        position: this.position\n      }), this.props.lastTransitionProps, this._isModal());\n    }\n  }, {\n    key: \"_preparePosition\",\n    value: function _preparePosition() {\n      if (this.gesturePosition) {\n        this.position = Animated.add(Animated.multiply(this.props.transitionProps.position, this.positionSwitch), Animated.multiply(this.gesturePosition, this.gestureSwitch));\n      } else {\n        this.position = this.props.transitionProps.position;\n      }\n    }\n  }]);\n\n  return StackViewLayout;\n}(React.Component);\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'column-reverse',\n    overflow: 'hidden'\n  },\n  scenes: {\n    flex: 1\n  },\n  floatingHeader: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0\n  }\n});\nexport default withOrientation(StackViewLayout);","map":{"version":3,"sources":["/Users/kharl/pawSpace/node_modules/react-navigation-stack/src/views/StackView/StackViewLayout.js"],"names":["React","SceneView","StackActions","NavigationActions","NavigationProvider","withOrientation","ScreenContainer","PanGestureHandler","State","Card","Header","TransitionConfigs","HeaderStyleInterpolator","StackGestureContext","clamp","supportsImprovedSpringAnimation","IPHONE_XS_HEIGHT","IPHONE_XR_HEIGHT","Dimensions","get","WINDOW_WIDTH","width","WINDOW_HEIGHT","height","IS_IPHONE_X","Platform","OS","isPad","isTVOS","EaseInOut","Easing","inOut","ease","HEADER_LAYOUT_PRESET","HEADER_TRANSITION_PRESET","HEADER_BACKGROUND_TRANSITION_PRESET","ANIMATION_DURATION","POSITION_THRESHOLD","GESTURE_RESPONSE_DISTANCE_HORIZONTAL","GESTURE_RESPONSE_DISTANCE_VERTICAL","USE_NATIVE_DRIVER","getDefaultHeaderHeight","isLandscape","StackViewLayout","props","_immediateIndex","_onFloatingHeaderLayout","e","nativeEvent","layout","state","floatingHeaderHeight","setState","_handlePanGestureStateChange","oldState","ACTIVE","positionSwitch","__getValue","_isMotionVertical","_handleReleaseVertical","_handleReleaseHorizontal","onGestureBegin","setValue","_renderCard","scene","transitionProps","shadowEnabled","cardOverlayEnabled","transparentCard","cardStyle","screenInterpolator","_transitionConfig","style","position","options","descriptor","hasHeader","header","headerMode","_getHeaderMode","paddingTopStyle","headerTransparent","paddingTop","key","_renderInnerScene","panGestureRef","createRef","gestureX","Animated","Value","gestureY","subtract","gestureSwitch","add","multiply","gestureEvent","event","translationX","translationY","useNativeDriver","__DEV__","Error","isValidElement","renderHeader","headerLeftInterpolator","headerTitleInterpolator","headerRightInterpolator","headerBackgroundInterpolator","backgroundTransitionPresetInterpolator","_getHeaderBackgroundTransitionPreset","passProps","navigation","mode","transitionPreset","_getHeaderTransitionPreset","layoutPreset","_getHeaderLayoutPreset","backTitleVisible","_getHeaderBackTitleVisible","leftInterpolator","titleInterpolator","rightInterpolator","backgroundInterpolator","resetToIndex","duration","spring","toValue","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","start","timing","easing","backFromIndex","scenes","Math","max","onCompleteAnimation","backFromScene","find","s","index","dispatch","back","route","immediate","completeTransition","_prevProps","_prepareGesture","_preparePosition","_prepareTransitionConfig","_prepareAnimated","floatingHeader","styles","_renderHeader","_gestureActivationCriteria","_isGestureEnabled","container","containerStyle","map","prevProps","prevState","_maybeCancelGesture","gestureResponseDistance","userGestureResponseDistance","_isModal","vertical","horizontal","_getGestureResponseDistance","isMotionInverted","_isMotionInverted","maxDeltaX","minOffsetY","hitSlop","top","bottom","minOffsetX","maxDeltaY","left","right","gesturesEnabled","gestureDirection","I18nManager","isRTL","distance","x","value","y","gesturePosition","undefined","_prepareGestureVertical","_prepareGestureHorizontal","divide","interpolate","inputRange","outputRange","extrapolate","immediateIndex","movementDirection","movedDistance","gestureVelocity","velocityX","defaultVelocity","velocity","abs","resetDuration","goBackDuration","_computeHorizontalGestureValue","onGestureCanceled","_reset","onGestureEnd","_goBack","velocityY","_computeVerticalGestureValue","headerBackgroundTransitionPreset","includes","forBackgroundWithFade","forBackgroundWithTranslation","forBackgroundWithInactiveHidden","console","error","join","JSON","stringify","headerLayoutPreset","warn","headerTransitionPreset","headerBackTitleVisible","enabledByDefault","getComponent","SceneComponent","screenProps","getTransitionConfig","transitionConfig","lastTransitionProps","Component","StyleSheet","create","flex","flexDirection","overflow"],"mappings":"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","sourcesContent":["import React from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  Platform,\n  View,\n  I18nManager,\n  Easing,\n  Dimensions,\n} from 'react-native';\nimport {\n  SceneView,\n  StackActions,\n  NavigationActions,\n  NavigationProvider,\n} from '@react-navigation/core';\nimport { withOrientation } from '@react-navigation/native';\nimport { ScreenContainer } from 'react-native-screens';\nimport { PanGestureHandler, State } from 'react-native-gesture-handler';\n\nimport Card from './StackViewCard';\nimport Header from '../Header/Header';\nimport TransitionConfigs from './StackViewTransitionConfigs';\nimport HeaderStyleInterpolator from '../Header/HeaderStyleInterpolator';\nimport StackGestureContext from '../../utils/StackGestureContext';\nimport clamp from '../../utils/clamp';\nimport { supportsImprovedSpringAnimation } from '../../utils/ReactNativeFeatures';\n\nconst IPHONE_XS_HEIGHT = 812; // iPhone X and XS\nconst IPHONE_XR_HEIGHT = 896; // iPhone XR and XS Max\nconst { width: WINDOW_WIDTH, height: WINDOW_HEIGHT } = Dimensions.get('window');\nconst IS_IPHONE_X =\n  Platform.OS === 'ios' &&\n  !Platform.isPad &&\n  !Platform.isTVOS &&\n  (WINDOW_HEIGHT === IPHONE_XS_HEIGHT ||\n    WINDOW_WIDTH === IPHONE_XS_HEIGHT ||\n    WINDOW_HEIGHT === IPHONE_XR_HEIGHT ||\n    WINDOW_WIDTH === IPHONE_XR_HEIGHT);\n\nconst EaseInOut = Easing.inOut(Easing.ease);\n\n/**\n * Enumerate possible values for validation\n */\nconst HEADER_LAYOUT_PRESET = ['center', 'left'];\nconst HEADER_TRANSITION_PRESET = ['fade-in-place', 'uikit'];\nconst HEADER_BACKGROUND_TRANSITION_PRESET = ['toggle', 'fade', 'translate'];\n\n/**\n * The max duration of the card animation in milliseconds after released gesture.\n * The actual duration should be always less then that because the rest distance\n * is always less then the full distance of the layout.\n */\nconst ANIMATION_DURATION = 500;\n\n/**\n * The gesture distance threshold to trigger the back behavior. For instance,\n * `1/2` means that moving greater than 1/2 of the width of the screen will\n * trigger a back action\n */\nconst POSITION_THRESHOLD = 1 / 2;\n\n/**\n * The distance of touch start from the edge of the screen where the gesture will be recognized\n */\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nconst USE_NATIVE_DRIVER = true;\n\nconst getDefaultHeaderHeight = isLandscape => {\n  if (Platform.OS === 'ios') {\n    if (isLandscape && !Platform.isPad) {\n      return 32;\n    } else if (IS_IPHONE_X) {\n      return 88;\n    } else {\n      return 64;\n    }\n  } else if (Platform.OS === 'android') {\n    return 56;\n  } else {\n    return 64;\n  }\n};\n\nclass StackViewLayout extends React.Component {\n  /**\n   * immediateIndex is used to represent the expected index that we will be on after a\n   * transition. To achieve a smooth animation when swiping back, the action to go back\n   * doesn't actually fire until the transition completes. The immediateIndex is used during\n   * the transition so that gestures can be handled correctly. This is a work-around for\n   * cases when the user quickly swipes back several times.\n   */\n  _immediateIndex = null;\n\n  constructor(props) {\n    super(props);\n    this.panGestureRef = React.createRef();\n    this.gestureX = new Animated.Value(0);\n    this.gestureY = new Animated.Value(0);\n    this.positionSwitch = new Animated.Value(1);\n    if (Animated.subtract) {\n      this.gestureSwitch = Animated.subtract(1, this.positionSwitch);\n    } else {\n      this.gestureSwitch = Animated.add(\n        1,\n        Animated.multiply(-1, this.positionSwitch)\n      );\n    }\n    this.gestureEvent = Animated.event(\n      [\n        {\n          nativeEvent: {\n            translationX: this.gestureX,\n            translationY: this.gestureY,\n          },\n        },\n      ],\n      {\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }\n    );\n\n    this.state = {\n      // Used when card's header is null and mode is float to make transition\n      // between screens with headers and those without headers smooth.\n      // This is not a great heuristic here. We don't know synchronously\n      // on mount what the header height is so we have just used the most\n      // common cases here.\n      floatingHeaderHeight: getDefaultHeaderHeight(props.isLandscape),\n    };\n  }\n\n  _renderHeader(scene, headerMode) {\n    const { options } = scene.descriptor;\n    const { header } = options;\n\n    if (__DEV__ && typeof header === 'string') {\n      throw new Error(\n        `Invalid header value: \"${header}\". The header option must be a valid React component or null, not a string.`\n      );\n    }\n\n    if (header === null && headerMode === 'screen') {\n      return null;\n    }\n\n    // check if it's a react element\n    if (React.isValidElement(header)) {\n      return header;\n    }\n\n    // Handle the case where the header option is a function, and provide the default\n    const renderHeader = header || (props => <Header {...props} />);\n\n    let {\n      headerLeftInterpolator,\n      headerTitleInterpolator,\n      headerRightInterpolator,\n      headerBackgroundInterpolator,\n    } = this._transitionConfig;\n\n    const backgroundTransitionPresetInterpolator = this._getHeaderBackgroundTransitionPreset();\n    if (backgroundTransitionPresetInterpolator) {\n      headerBackgroundInterpolator = backgroundTransitionPresetInterpolator;\n    }\n\n    const { transitionProps, ...passProps } = this.props;\n\n    return (\n      <NavigationProvider value={scene.descriptor.navigation}>\n        {renderHeader({\n          ...passProps,\n          ...transitionProps,\n          position: this.position,\n          scene,\n          mode: headerMode,\n          transitionPreset: this._getHeaderTransitionPreset(),\n          layoutPreset: this._getHeaderLayoutPreset(),\n          backTitleVisible: this._getHeaderBackTitleVisible(),\n          leftInterpolator: headerLeftInterpolator,\n          titleInterpolator: headerTitleInterpolator,\n          rightInterpolator: headerRightInterpolator,\n          backgroundInterpolator: headerBackgroundInterpolator,\n        })}\n      </NavigationProvider>\n    );\n  }\n\n  _reset(resetToIndex, duration) {\n    if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n      Animated.spring(this.props.transitionProps.position, {\n        toValue: resetToIndex,\n        stiffness: 6000,\n        damping: 100,\n        mass: 3,\n        overshootClamping: true,\n        restDisplacementThreshold: 0.01,\n        restSpeedThreshold: 0.01,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start();\n    } else {\n      Animated.timing(this.props.transitionProps.position, {\n        toValue: resetToIndex,\n        duration,\n        easing: EaseInOut,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start();\n    }\n  }\n\n  _goBack(backFromIndex, duration) {\n    const { navigation, position, scenes } = this.props.transitionProps;\n    const toValue = Math.max(backFromIndex - 1, 0);\n\n    // set temporary index for gesture handler to respect until the action is\n    // dispatched at the end of the transition.\n    this._immediateIndex = toValue;\n\n    const onCompleteAnimation = () => {\n      this._immediateIndex = null;\n      const backFromScene = scenes.find(s => s.index === toValue + 1);\n      if (backFromScene) {\n        navigation.dispatch(\n          NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true,\n          })\n        );\n        navigation.dispatch(StackActions.completeTransition());\n      }\n    };\n\n    if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n      Animated.spring(position, {\n        toValue,\n        stiffness: 7000,\n        damping: 300,\n        mass: 3,\n        overshootClamping: true,\n        restDisplacementThreshold: 0.01,\n        restSpeedThreshold: 0.01,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start(onCompleteAnimation);\n    } else {\n      Animated.timing(position, {\n        toValue,\n        duration,\n        easing: EaseInOut,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start(onCompleteAnimation);\n    }\n  }\n\n  _onFloatingHeaderLayout = e => {\n    const { height } = e.nativeEvent.layout;\n    if (height !== this.state.floatingHeaderHeight) {\n      this.setState({ floatingHeaderHeight: height });\n    }\n  };\n\n  _prepareAnimated() {\n    if (this.props === this._prevProps) {\n      return;\n    }\n    this._prevProps = this.props;\n\n    this._prepareGesture();\n    this._preparePosition();\n    this._prepareTransitionConfig();\n  }\n\n  render() {\n    this._prepareAnimated();\n\n    const { transitionProps } = this.props;\n    const {\n      navigation: {\n        state: { index },\n      },\n      scenes,\n    } = transitionProps;\n\n    const headerMode = this._getHeaderMode();\n    let floatingHeader = null;\n    if (headerMode === 'float') {\n      const { scene } = transitionProps;\n      floatingHeader = (\n        <View\n          style={styles.floatingHeader}\n          pointerEvents=\"box-none\"\n          onLayout={this._onFloatingHeaderLayout}\n        >\n          {this._renderHeader(scene, headerMode)}\n        </View>\n      );\n    }\n\n    return (\n      <PanGestureHandler\n        {...this._gestureActivationCriteria()}\n        ref={this.panGestureRef}\n        onGestureEvent={this.gestureEvent}\n        onHandlerStateChange={this._handlePanGestureStateChange}\n        enabled={index > 0 && this._isGestureEnabled()}\n      >\n        <Animated.View\n          style={[styles.container, this._transitionConfig.containerStyle]}\n        >\n          <StackGestureContext.Provider value={this.panGestureRef}>\n            <ScreenContainer style={styles.scenes}>\n              {scenes.map(this._renderCard)}\n            </ScreenContainer>\n            {floatingHeader}\n          </StackGestureContext.Provider>\n        </Animated.View>\n      </PanGestureHandler>\n    );\n  }\n\n  componentDidUpdate(prevProps) {\n    const { state: prevState } = prevProps.transitionProps.navigation;\n    const { state } = this.props.transitionProps.navigation;\n    if (prevState.index !== state.index) {\n      this._maybeCancelGesture();\n    }\n  }\n\n  _getGestureResponseDistance() {\n    const { scene } = this.props.transitionProps;\n    const { options } = scene.descriptor;\n    const {\n      gestureResponseDistance: userGestureResponseDistance = {},\n    } = options;\n\n    // Doesn't make sense for a response distance of 0, so this works fine\n    return this._isModal()\n      ? userGestureResponseDistance.vertical ||\n          GESTURE_RESPONSE_DISTANCE_VERTICAL\n      : userGestureResponseDistance.horizontal ||\n          GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n  }\n\n  _gestureActivationCriteria() {\n    const { layout } = this.props.transitionProps;\n    const gestureResponseDistance = this._getGestureResponseDistance();\n    const isMotionInverted = this._isMotionInverted();\n\n    if (this._isMotionVertical()) {\n      const height = layout.height.__getValue();\n\n      return {\n        maxDeltaX: 15,\n        minOffsetY: isMotionInverted ? -5 : 5,\n        hitSlop: isMotionInverted\n          ? { top: -height + gestureResponseDistance }\n          : { bottom: -height + gestureResponseDistance },\n      };\n    } else {\n      const width = layout.width.__getValue();\n      const hitSlop = -width + gestureResponseDistance;\n\n      return {\n        minOffsetX: isMotionInverted ? -5 : 5,\n        maxDeltaY: 20,\n        hitSlop: isMotionInverted ? { left: hitSlop } : { right: hitSlop },\n      };\n    }\n  }\n\n  _isGestureEnabled() {\n    const gesturesEnabled = this.props.transitionProps.scene.descriptor.options\n      .gesturesEnabled;\n    return typeof gesturesEnabled === 'boolean'\n      ? gesturesEnabled\n      : Platform.OS === 'ios';\n  }\n\n  _isMotionVertical() {\n    return this._isModal();\n  }\n\n  _isModal() {\n    return this.props.mode === 'modal';\n  }\n\n  // This only currently applies to the horizontal gesture!\n  _isMotionInverted() {\n    const {\n      transitionProps: { scene },\n    } = this.props;\n    const { options } = scene.descriptor;\n    const { gestureDirection } = options;\n\n    if (this._isModal()) {\n      return gestureDirection === 'inverted';\n    } else {\n      return typeof gestureDirection === 'string'\n        ? gestureDirection === 'inverted'\n        : I18nManager.isRTL;\n    }\n  }\n\n  _computeHorizontalGestureValue({ translationX }) {\n    const {\n      transitionProps: { navigation, layout },\n    } = this.props;\n\n    const { index } = navigation.state;\n\n    // TODO: remove this __getValue!\n    const distance = layout.width.__getValue();\n\n    const x = this._isMotionInverted() ? -1 * translationX : translationX;\n\n    const value = index - x / distance;\n    return clamp(index - 1, value, index);\n  }\n\n  _computeVerticalGestureValue({ translationY }) {\n    const {\n      transitionProps: { navigation, layout },\n    } = this.props;\n\n    const { index } = navigation.state;\n\n    // TODO: remove this __getValue!\n    const distance = layout.height.__getValue();\n\n    const y = this._isMotionInverted() ? -1 * translationY : translationY;\n    const value = index - y / distance;\n    return clamp(index - 1, value, index);\n  }\n\n  _handlePanGestureStateChange = ({ nativeEvent }) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      // Gesture was cancelled! For example, some navigation state update\n      // arrived while the gesture was active that cancelled it out\n      if (this.positionSwitch.__getValue() === 1) {\n        return;\n      }\n\n      if (this._isMotionVertical()) {\n        this._handleReleaseVertical(nativeEvent);\n      } else {\n        this._handleReleaseHorizontal(nativeEvent);\n      }\n    } else if (nativeEvent.state === State.ACTIVE) {\n      this.props.onGestureBegin && this.props.onGestureBegin();\n\n      // Switch to using gesture position\n      this.positionSwitch.setValue(0);\n\n      // By enabling the gesture switch and ignoring the position here we\n      // end up with a quick jump to the initial value and then back to the\n      // gesture. While this isn't ideal, it's preferred over preventing new\n      // gestures during the animation (all gestures should be interruptible)\n      // and we will properly fix it (interruptible and from the correct position)\n      // when we integrate reanimated. If you prefer to prevent gestures during\n      // transitions, then fork this library, comment the positionSwitch value set above,\n      // and uncomment the following two lines.\n      // if (!this.props.transitionProps.position._animation) {\n      //   this.positionSwitch.setValue(0);\n      // }\n    }\n  };\n\n  // note: this will not animated so nicely because the position is unaware\n  // of the gesturePosition, so if we are in the middle of swiping the screen away\n  // and back is programatically fired then we will reset to the initial position\n  // and animate from there\n  _maybeCancelGesture() {\n    this.positionSwitch.setValue(1);\n  }\n\n  _prepareGesture() {\n    if (!this._isGestureEnabled()) {\n      if (this.positionSwitch.__getValue() !== 1) {\n        this.positionSwitch.setValue(1);\n      }\n      this.gesturePosition = undefined;\n      return;\n    }\n\n    // We can't run the gesture if width or height layout is unavailable\n    if (\n      this.props.transitionProps.layout.width.__getValue() === 0 ||\n      this.props.transitionProps.layout.height.__getValue() === 0\n    ) {\n      return;\n    }\n\n    if (this._isMotionVertical()) {\n      this._prepareGestureVertical();\n    } else {\n      this._prepareGestureHorizontal();\n    }\n  }\n\n  _prepareGestureHorizontal() {\n    const { index } = this.props.transitionProps.navigation.state;\n\n    if (this._isMotionInverted()) {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.divide(this.gestureX, this.props.transitionProps.layout.width)\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    } else {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.multiply(\n          -1,\n          Animated.divide(\n            this.gestureX,\n            this.props.transitionProps.layout.width\n          )\n        )\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    }\n  }\n\n  _prepareGestureVertical() {\n    const { index } = this.props.transitionProps.navigation.state;\n\n    if (this._isMotionInverted()) {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.divide(this.gestureY, this.props.transitionProps.layout.height)\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    } else {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.multiply(\n          -1,\n          Animated.divide(\n            this.gestureY,\n            this.props.transitionProps.layout.height\n          )\n        )\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    }\n  }\n\n  _handleReleaseHorizontal(nativeEvent) {\n    const {\n      transitionProps: { navigation, position, layout },\n    } = this.props;\n    const { index } = navigation.state;\n    const immediateIndex =\n      this._immediateIndex == null ? index : this._immediateIndex;\n\n    // Calculate animate duration according to gesture speed and moved distance\n    const distance = layout.width.__getValue();\n    const movementDirection = this._isMotionInverted() ? -1 : 1;\n    const movedDistance = movementDirection * nativeEvent.translationX;\n    const gestureVelocity = movementDirection * nativeEvent.velocityX;\n    const defaultVelocity = distance / ANIMATION_DURATION;\n    const velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n    const resetDuration = this._isMotionInverted()\n      ? (distance - movedDistance) / velocity\n      : movedDistance / velocity;\n    const goBackDuration = this._isMotionInverted()\n      ? movedDistance / velocity\n      : (distance - movedDistance) / velocity;\n\n    // Get the current position value and reset to using the statically driven\n    // (rather than gesture driven) position.\n    const value = this._computeHorizontalGestureValue(nativeEvent);\n    position.setValue(value);\n    this.positionSwitch.setValue(1);\n\n    // If the speed of the gesture release is significant, use that as the indication\n    // of intent\n    if (gestureVelocity < -50) {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this._reset(immediateIndex, resetDuration);\n      return;\n    }\n    if (gestureVelocity > 50) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this._goBack(immediateIndex, goBackDuration);\n      return;\n    }\n\n    // Then filter based on the distance the screen was moved. Over a third of the way swiped,\n    // and the back will happen.\n    if (value <= index - POSITION_THRESHOLD) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this._goBack(immediateIndex, goBackDuration);\n    } else {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this._reset(immediateIndex, resetDuration);\n    }\n  }\n\n  _handleReleaseVertical(nativeEvent) {\n    const {\n      transitionProps: { navigation, position, layout },\n    } = this.props;\n    const { index } = navigation.state;\n    const immediateIndex =\n      this._immediateIndex == null ? index : this._immediateIndex;\n\n    // Calculate animate duration according to gesture speed and moved distance\n    const distance = layout.height.__getValue();\n    const isMotionInverted = this._isMotionInverted();\n    const movementDirection = isMotionInverted ? -1 : 1;\n    const movedDistance = movementDirection * nativeEvent.translationY;\n    const gestureVelocity = movementDirection * nativeEvent.velocityY;\n    const defaultVelocity = distance / ANIMATION_DURATION;\n    const velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n    const resetDuration = isMotionInverted\n      ? (distance - movedDistance) / velocity\n      : movedDistance / velocity;\n    const goBackDuration = isMotionInverted\n      ? movedDistance / velocity\n      : (distance - movedDistance) / velocity;\n\n    const value = this._computeVerticalGestureValue(nativeEvent);\n    position.setValue(value);\n    this.positionSwitch.setValue(1);\n\n    // If the speed of the gesture release is significant, use that as the indication\n    // of intent\n    if (gestureVelocity < -50) {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this._reset(immediateIndex, resetDuration);\n      return;\n    }\n    if (gestureVelocity > 50) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this._goBack(immediateIndex, goBackDuration);\n      return;\n    }\n\n    // Then filter based on the distance the screen was moved. Over a third of the way swiped,\n    // and the back will happen.\n    if (value <= index - POSITION_THRESHOLD) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this._goBack(immediateIndex, goBackDuration);\n    } else {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this._reset(immediateIndex, resetDuration);\n    }\n  }\n\n  _getHeaderMode() {\n    if (this.props.headerMode) {\n      return this.props.headerMode;\n    }\n    if (Platform.OS !== 'ios' || this.props.mode === 'modal') {\n      return 'screen';\n    }\n    return 'float';\n  }\n\n  _getHeaderBackgroundTransitionPreset() {\n    const { headerBackgroundTransitionPreset } = this.props;\n    if (headerBackgroundTransitionPreset) {\n      if (\n        HEADER_BACKGROUND_TRANSITION_PRESET.includes(\n          headerBackgroundTransitionPreset\n        )\n      ) {\n        if (headerBackgroundTransitionPreset === 'fade') {\n          return HeaderStyleInterpolator.forBackgroundWithFade;\n        } else if (headerBackgroundTransitionPreset === 'translate') {\n          return HeaderStyleInterpolator.forBackgroundWithTranslation;\n        } else if (headerBackgroundTransitionPreset === 'toggle') {\n          return HeaderStyleInterpolator.forBackgroundWithInactiveHidden;\n        }\n      } else if (__DEV__) {\n        console.error(\n          `Invalid configuration applied for headerBackgroundTransitionPreset - expected one of ${HEADER_BACKGROUND_TRANSITION_PRESET.join(\n            ', '\n          )} but received ${JSON.stringify(headerBackgroundTransitionPreset)}`\n        );\n      }\n    }\n\n    return null;\n  }\n\n  _getHeaderLayoutPreset() {\n    const { headerLayoutPreset } = this.props;\n    if (headerLayoutPreset) {\n      if (__DEV__) {\n        if (\n          this._getHeaderTransitionPreset() === 'uikit' &&\n          headerLayoutPreset === 'left' &&\n          Platform.OS === 'ios'\n        ) {\n          console.warn(\n            `headerTransitionPreset with the value 'uikit' is incompatible with headerLayoutPreset 'left'`\n          );\n        }\n      }\n      if (HEADER_LAYOUT_PRESET.includes(headerLayoutPreset)) {\n        return headerLayoutPreset;\n      }\n\n      if (__DEV__) {\n        console.error(\n          `Invalid configuration applied for headerLayoutPreset - expected one of ${HEADER_LAYOUT_PRESET.join(\n            ', '\n          )} but received ${JSON.stringify(headerLayoutPreset)}`\n        );\n      }\n    }\n\n    if (Platform.OS !== 'ios') {\n      return 'left';\n    } else {\n      return 'center';\n    }\n  }\n\n  _getHeaderTransitionPreset() {\n    // On Android or with header mode screen, we always just use in-place,\n    // we ignore the option entirely (at least until we have other presets)\n    if (Platform.OS !== 'ios' || this._getHeaderMode() === 'screen') {\n      return 'fade-in-place';\n    }\n\n    const { headerTransitionPreset } = this.props;\n    if (headerTransitionPreset) {\n      if (HEADER_TRANSITION_PRESET.includes(headerTransitionPreset)) {\n        return headerTransitionPreset;\n      }\n\n      if (__DEV__) {\n        console.error(\n          `Invalid configuration applied for headerTransitionPreset - expected one of ${HEADER_TRANSITION_PRESET.join(\n            ', '\n          )} but received ${JSON.stringify(headerTransitionPreset)}`\n        );\n      }\n    }\n\n    return 'fade-in-place';\n  }\n\n  _getHeaderBackTitleVisible() {\n    const { headerBackTitleVisible } = this.props;\n    const layoutPreset = this._getHeaderLayoutPreset();\n\n    // Even when we align to center on Android, people should need to opt-in to\n    // showing the back title\n    const enabledByDefault = !(\n      layoutPreset === 'left' || Platform.OS !== 'ios'\n    );\n\n    return typeof headerBackTitleVisible === 'boolean'\n      ? headerBackTitleVisible\n      : enabledByDefault;\n  }\n\n  _renderInnerScene(scene) {\n    const { navigation, getComponent } = scene.descriptor;\n    const SceneComponent = getComponent();\n\n    const { screenProps } = this.props;\n    const headerMode = this._getHeaderMode();\n    if (headerMode === 'screen') {\n      return (\n        <View style={styles.container}>\n          <View style={styles.scenes}>\n            <SceneView\n              screenProps={screenProps}\n              navigation={navigation}\n              component={SceneComponent}\n            />\n          </View>\n          {this._renderHeader(scene, headerMode)}\n        </View>\n      );\n    }\n    return (\n      <SceneView\n        screenProps={screenProps}\n        navigation={navigation}\n        component={SceneComponent}\n      />\n    );\n  }\n\n  _prepareTransitionConfig() {\n    this._transitionConfig = TransitionConfigs.getTransitionConfig(\n      this.props.transitionConfig,\n      {\n        ...this.props.transitionProps,\n        position: this.position,\n      },\n      this.props.lastTransitionProps,\n      this._isModal()\n    );\n  }\n\n  _preparePosition() {\n    if (this.gesturePosition) {\n      this.position = Animated.add(\n        Animated.multiply(\n          this.props.transitionProps.position,\n          this.positionSwitch\n        ),\n        Animated.multiply(this.gesturePosition, this.gestureSwitch)\n      );\n    } else {\n      this.position = this.props.transitionProps.position;\n    }\n  }\n\n  _renderCard = scene => {\n    const {\n      transitionProps,\n      shadowEnabled,\n      cardOverlayEnabled,\n      transparentCard,\n      cardStyle,\n    } = this.props;\n\n    const { screenInterpolator } = this._transitionConfig;\n    const style =\n      screenInterpolator &&\n      screenInterpolator({\n        ...transitionProps,\n        shadowEnabled,\n        cardOverlayEnabled,\n        position: this.position,\n        scene,\n      });\n\n    // When using a floating header, we need to add some top\n    // padding on the scene.\n    const { options } = scene.descriptor;\n    const hasHeader = options.header !== null;\n    const headerMode = this._getHeaderMode();\n    let paddingTopStyle;\n    if (hasHeader && headerMode === 'float' && !options.headerTransparent) {\n      paddingTopStyle = { paddingTop: this.state.floatingHeaderHeight };\n    }\n\n    return (\n      <Card\n        {...transitionProps}\n        key={`card_${scene.key}`}\n        position={this.position}\n        realPosition={transitionProps.position}\n        animatedStyle={style}\n        transparent={transparentCard}\n        style={[paddingTopStyle, cardStyle]}\n        scene={scene}\n      >\n        {this._renderInnerScene(scene)}\n      </Card>\n    );\n  };\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    // Header is physically rendered after scenes so that Header won't be\n    // covered by the shadows of the scenes.\n    // That said, we'd have use `flexDirection: 'column-reverse'` to move\n    // Header above the scenes.\n    flexDirection: 'column-reverse',\n    overflow: 'hidden',\n  },\n  scenes: {\n    flex: 1,\n  },\n  floatingHeader: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0,\n  },\n});\n\nexport default withOrientation(StackViewLayout);\n"]},"metadata":{},"sourceType":"module"}